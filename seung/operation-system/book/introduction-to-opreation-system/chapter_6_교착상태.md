# Chapter 06 교착 상태

# Table of Contents

-   [1. 교착 상태의 개요](#1-교착-상태의-개요)

    -   [1-1. 교착 상태의 정의](#1-1-교착-상태의-정의)
    -   [1-2. 교착 상태의 발생](#1-2-교착-상태의-발생)
    -   [1-3. 자원 할당 그래프](#1-3-자원-할당-그래프)

-   [2. 교착 상태 필요 조건](#2-교착-상태-필요조건)
    -   [2-1. 교착 상태 필요조건](#2-1-교착-상태-필요조건)
    -   [2-2. 식사하는 철학자 문제와 교착 상태 필요조건](#2-2-식사하는-철학자-문제와-교착-상태-필요조건)
-   [3. 교착 상태 해결 방법](#3-교착-상태-해결-방법)
    -   [3-1. 교착 상태 해결 방법](#3-1-교착-상태-해결-방법)
    -   [3-2. 교착 상태 예방](#3-2-교착-상태-예방)
    *   [3-3. 교착 상태 회피](#3-3-교착-상태-회피)
    *   [3-4. 교착 상태 검출](#3-4-교착-상태-검출)

## 1. 교착 상태의 개요

### 1-1. 교착 상태의 정의

-   `교착 상태`: 2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태
    -   `아사 현상(starvation)`: 운영체제가 잘못된 정책을 사용해 프로세스의 작업이 지연되는 문제
    -   `교착 상태(deadlock)`: 여러 프로세스가 작업을 진행하다 보니 자연적으로 일어나는 문제. 운영체제는 교착 상태가 발생하면 강압적으로 해결해야 한다.

### 1-2. 교착 상태의 발생

-   시스템 자원, 공유 변수(파일), 응용 프로그램 등을 사용할 때 발생할 수 있다.

    -   시스템 자원
        -   교착 상태는 다른 프로세스와 공유할 수 없는 자원을 사용할 때 발생. 동시에 같이 사용할 수 없는 시스템 자원을 할당받은 후 양보하지 않는 경우 교착상태 발생가능.
    -   공유 변수

        -   교착 상태는 공유 변수를 사용할 때도 발생.

        ```
        boolean lock1=false;
        boolean lock2=false;

        // process 1
        lock1=true;
        // (1)
        while(lock2==true);
        	// 임계 구역
        lock1=false;

        // process 2
        lock2=true;
        // (2)
        while(lock1==true);
        	// 임계 구역
        lock2=false;
        ```

        -   (1), (2)위치에서 프로세스들이 멈췄다면 교착상태 발생.

    -   응용 프로그램
        -   데이터베이스 같은 응용 프로그램에서도 교착 상태가 발생. 여러 프로세스가 데이터 베이스에 저장된 데이터를 사용할 때는 데이터의 일관성을 유지해야 한다. 이런 데이터의 일관성을 유지하기 위해 잠금을 사용하는데 이 때 교착상태 발생 가능.

### 1-3. 자원 할당 그래프

-   `자원 할당 그래프(resource allocation graph)`는 프로게스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지 방향성이 있는 그래프로 표현한 것.
    -   프로세스는 원, 자원은 사각형으로 표현

<p align="center">
	<label>
    	<img src="./image/chapter6/resoure_allocation_graph.png" alt="프로세스 간 통신 종류" />
		출처: https://gamball.tistory.com/m/23
	</label>
<p>

-   자원을 사용하고 있는 경우 자원으로부터 프로세스로 향하는 화살표로 표시
-   프로세스가 자원을 기다리는 경우 프로세스로부터 자원으로 향하는 화살표로 표시
-   하나의 자원을 동시에 사용하면 이를 `다중 자원(multiple resource)`라고 부른다. 다중 자원은 수용할 수 있는 프로세스 수를 사각형 안에 작은 동그라미로 표현.
-   식사하는 철학자 문제
    -   원형 식탁에 앉은 철학자들은 음식을 먹기 위해 왼쪽 포크를 잡은 뒤 오른쪽 포크를 잡아야만 식사를 할 수 있다. 이 때 학자들은 모두 왼쪽 포크를 집은 상태에서 오른쪽 포크를 집기위해 보지만 이미 다른 철학자가 왼쪽 포크로 사용하고 있기 때문에 음식을 먹지 못해 굶어 죽는다.
    -   식사하는 철학자 문제 중 교착 상태가 발생하는 조건
        1. 철학자들은 서로 포크를 공유할 수 없다.(상호 배제)
        2. 각 철학자는 다른 철학자의 포크를 뺏을 수 없다.(비선점)
        3. 각 철학자는 왼쪽 포크를 잡은 채 오른쪽 포크를 기다린다.(점유와 대기)
        4. 자원 할당 그래프가 원형이다.(원형 대기))

## 2. 교착 상태 필요조건

### 2-1. 교착 상태 필요조건

-   교착 상태 필요조건
    -   `상호 배제`: 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 함. 배타적인 자원은 임계구역으로 보호되기에 다른 프로세스가 동시에 사용할 수 없다.
    -   `비선점`: 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 함. 자원을 뺏을 수 없으면 공유할 수 없으므로 교착 상태 발생
    -   `점유와 대기`: 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태
    -   `원형 대기`: 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 한다. 특정 자원에 대해서 점유와 대기를 한다고 해서 모두 교착 상태에 빠지는 것은 아님. 점유와 대기를 하는 프로세스들이 서로 방해하는 방향이 원을 이루면서 프로세스들이 서로 양보하지 않기 때문.

*   **교착상태는 상호 배제, 비선점, 점유와 대기, 원형 대기를 모두 충족해야 발생하고, 이 중 단 하나라도 충족하지 않으면 발생하지 않는다. 따라서 이 네 가지 조건을 교착 상태 필요조건이라고 한다.**
*   `상호 배제`와 `비선점` 조건은 _자원이 어떤 특징을 가지는지_ 나타낸다. 자원을 동시에 공유할 수도 없고 중간에 빼앗을 수도 없다면 자원을 가진 프로세스가 자원을 내놓을 때까지 무작정 기다리는 교착 상태 발생. 즉 임계구역과 관련이 있다. 임계구역을 위해 잠금 장치를 사용하면 상호 배제와 비선점 조건이 보장된다. 이런 자원이 아래의 조건까지 더해지면 교착 상태 발생 가능.
*   `점유와 대기`, `원형 대기 조건`은 프로세스가 어떤 행위를 하고 있는지 나타냄. 프로세스가 자원을 점유 및 대기하고 있는 상태에서 다른 프로세스를 방해하는 방향이 원을 이루면 서로 양보하지 않기 때문에 교착상태 발생

### 2-2. 식사하는 철학자 문제와 교착 상태 필요조건

-   `상호 배제`: 이 문제에서 포크는 한 사람이 사용하면 다른 사람이 사용할 수 없는 배타적인 자원. 배타적인 자원을 여러 프로세스가 사용하는 경우 교착 상태 발생
-   `비선점`: 자원을 빼앗을 수 있다는 것은 시간 간격을 두고 그 자원을 공유할 수 있다는 의미이므로 상호 배제가 성립되지 않음. 즉 교착상태가 발생하지 않음.
-   `점유와 대기`: 한 철학자가 두 자원을 모두 점유하거나 기다리는 것은 서로 진행을 방해하는 것이 아니라, 현재 작업을 진행하는 쪽과 기다리는 쪽의 선후 관계를 만든다는 의미. 한 프로세스가 자원을 점유한 상태에서 다른 프로세스의 자원을 기다리면 서로 진행을 방해하는 상태가 됨 (교착 상태)
-   `원형 대기`: 원을 이룬다는 것은 선후 관계를 결정할 수 없어 문제가 계속 맴돈다는 의미. 점유와 대기를 하는 프로세스들이 원을 이루면 서로 진행을 방해하는 상태가 되므로 교착상태 발생.
-   `교착 상태`와 `아사 현상`은 다르다.
    -   `아사 현상`은 정책상 잘못이나 오류로 인해 특정 프로세스의 작업이 이루어지지 않는 것. 몇 번 이상 양보했따면 더 이상 양보하지 않도록 조정하는 에이징으로 해결 가능
    -   `교착 상태`는 정책상 잘못이나 오류가 없어도 자연적으로 발생. 즉 에이징으로, 정책을 바꿈으로써 막을 수 없다. 아사 현상보다 처리하기가 복잡.

## 3. 교착 상태 해결 방법

### 3-1. 교착 상태 해결 방법

-   예방, 회피, 검출 및 발견된 후에 자원을 회복하는 방법까지 있음.
    |해결방법|특징|
    |---|---|
    |교착 상태 예방|교착 상태를 유발하는 네 가지 조건을 무력화|
    |교착 상태 회피|교착 상태가 발생하지 않는 수준으로 자원 할당|
    |교착 상태 검출|자원 할당 그래프를 사용하여 교착 상태를 발견|
    |교착 상태 회복|교착 상태를 검출한 후 해결|
    -   교착 상태 예방
        -   교착 상태를 유발하는 네 가지 조건이 발생하지 않도록 무력화하는 방식(상호 배제, 비선점, 점유와 대기, 원형 대기) 이 중 하나라도 막는다면 교착 상태가 발생하지 않음. 하지만 실효성이 적어 잘 사용되지 않음.
    -   교착 상태 회피
        -   자원 할당량을 조절하여 교착 상태 해결. 자원을 할당하다가 교착 상태를 유발할 가능성이 있다고 판단되면 자원 할당을 중단하고 지켜봄. 그러나 자원을 얼마만큼 할당해야 교착 상태가 발생하지 않는다는 보장이 없기 때문에 실효성이 적다.
    -   교착 상태 검출과 회복 (현실적)
        -   교착 상태 검출은 어떤 제약을 가하지 않고 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴보는 방식. 만약 교착 상태가 발생하면 교착 상태 회복 단계가 진행. 현실적인 접근 방법.

### 3-2. 교착 상태 예방

-   교착 상태를 유발하는 네 가지 조건 중 하나라도 발생하지 않도록 막아 교착 상태를 처리하는 방식
    1.  상호 배제 예방
    -   시스템 내에 있는 상호 배타적인 모든 자원, 즉 독점적으로 사용할 수 있는 자원을 없애버리는 방법. 시스템 내의 모든 자원을 공유할 수 있으면 교착 상태 발생하지 않음.
    -   그러나 현실적으로 모든 자원을 공유할 수 없다. 즉, 상호 배제를 무력화하는 것은 사실상 어렵다.
    2.  비선점 예방
    -   모든 자원을 빼앗을 수 있도록 만드는 방법. 임계구역을 보호하기 위해 잠금을 사용하면 자원을 빼앗을 수 없을 뿐만아니라 상호 배제도 보장할 수 없다. 따라서 사실상 시스템의 모든 자원을 빼앗을 수 있도록 하지 못한다.
    -   자원을 빼앗을 수 있도록 할지라도 어떤 기준으로 빼앗을지, 빼앗은 시간 중 얼마나 사용할지 결정하기가 더 어렵다. 또 이 방법은 아사 현상을 일으킨다. 예를 들어 우선 순위가 높은 프로세스가 우선 순위가 낮은 프로세스의 자원을 무조건 빼앗을 수 있다고 가정한다면 자기보다 우선 순위가 높은 프로세스가 계속 들어오면 우선 순위가 가장 낮은 프로세스는 무조건 아사 현상에 빠짐.
    -   아사 현상은 에이징으로 해결 가능한데, 이렇게 양보하다 에이징이 되어 결국 무조건 자원을 점유하게 된다면 해당 자원은 비선점 자원이 되어 다시 교착 상태에 빠질 수 있다. 즉 에이징을 이용하는 것도 힘들다. 따라서 비선점 조건을 무력화 하기 어렵다.
    3.  점유와 대기 예방
    -   프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 한다. 전부 할당하거나 전부 할당하지 않음. 이를 위해 프로세스는 시작 초기에 자신이 사용하려는 모든 자원을 한꺼번에 점유하거나, 그렇지 못할 경우 자원을 모두 반납해야함.
    -   상호 배제 예방과 비선점 예방은 자원에 대한 제약을 풀어버리는 것. 그러나 임계구역으로 보호받는 자원에 대한 제약은 풀기 어렵다. 점유와 대기 예방은 자원이 아닌 프로세스의 자원 사용 방식을 변화시켜 교착 상태를 처리한다는 점에서 의미 있다.
        -   단점
        1. 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다.
        2. 자원의 활용성이 떨어진다. - 프로세스가 앞으로 사용할 자원까지 선점해서 그 자원을 필요로 하는 다른 프로세스의 작업이 진행되지 않음. 당장 사용하지 않을 자원을 미리 선점하여 자원 낭비가 심함.
        3. 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리. - 많은 자원을 사용하는 프로세스는 자원을 동시에 확보하기 어렵다. 아사현상 발생
        4. 결국 일괄 작업 방식으로 동작 - 키보드, 마우스 등의 시스템 자원은 대부분의 프로세스가 필요로 하는 자원인데, 이러한 자원을 확보한 순서대로 실행하면 그 자원을 획득한 프로세스가 작업을 끝내야 다른 프로세스가 작업할 수 있다. 즉 효율이 떨어진다.
    4.  원형 대기 예방
    -   점유와 대기를 하는 프로세스들이 원형을 이루지 못하도록 막음. 프로세스들이 한 줄로 길게 늘어선다면 그 줄의 맨 끝에서부터 문제 해결 가능.
    -   자원을 한 방향으로만 사용하도록 설정하여 원형 대기 예방 가능. 모든 자원에 숫자를 부여하고 숫자가 큰 방향으로만 자원을 할당. 숫자가 작은 자원을 잡은 상태에서 큰 숫자를 잡는 것은 허용하지만 반대는 허용하지 않음.
        -   단점
        1. 프로세스 작업 진행에 유연성이 떨어짐 - 숫자가 큰 것을 집고 작은 자원을 할당받지 못하게 하는데 이 부분이 유연성을 떨어뜨림
        2. 자원의 번호를 어떻게 부여할 것인가
    5.  교착 상태 예방 정리
    -   교착 상태 예방은 교착 상태를 유발하는 네 가지 조건이 일어나지 않도록 제약을 가하는 방법 그러나 상호 배제와 비선점은 예방하기 어렵고, 점유와 대기, 원형 대기 예방은 프로세스 작업 방식을 제한하고 자원을 낭비한다.

### 3-3. 교착 상태 회피

1. 교착 상태 회피의 개념

-   `교착 상태 회피`는 프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착 상태가 발생하는지 파악하여 그 수준 이하로 자원을 나누어주는 방법. 교착 상태가 발생하는 범위에 있으면 프로세스를 대기 시킴.
-   교착 상태 회피는 시스템의 운영 방식에 변경을 가하지 않기 때문에 교착 상태 예방보다 좀 더 유연함.
-   자원을 많이 할당할수록 교착 상태가 발생할 확률이 커진다.
-   교착 상태 회피는 자원의 총 수와 현재 할당된 자원의 수를 기준으로 시스템을 `안정 상태`와 `불안정 상태`로 나눈다. 시스템이 안정 상태를 유지하도록 자원을 할당. 불안정 상태에서 항상 교착 상태가 발생하지는 않음. 교착 상태는 불안정 상태의 일부분. 불안정 상태가 커질수록 교착 상태 확률이 높아짐.

2. 은행원 알고리즘

-   데잌스트라가 제안한 알고리즘. 은행이 대출을 해주는 방식, 대출 금액이 가능한 범위면 허용 그렇지 않으면 불가 한 것과 유사하여 이렇게 불림.
-   은행원 알고리즘은 최악의 경우를 기준으로 함으로써 문제 상황을 철저히 피하여 교착 상태를 막음.
-   은행원 알고리즘은 자신이 사용할 자원의 최대 수를 운영체제에 알려줌. 운영체제가 자원을 할당할 때 시스템의 상태를 파악하는 데 꼭 필요한 정보이기 때문.
-   각 프로세스에 할당된 자원의 수는 `할당 자원`에 표시. 각 프로세스마다 자신이 선언한 최대 자원에서 현재 할당된 자원의 수를 빼면 `기대 자원`이 됨. 전체 자원에서 각 프로세스에 할당되고 남은 자원의 수가 `가용 자원`. 즉, 전체 자원에서 모든 프로세스의 할당 자원을 뺀 값.
-   자원 할당 기준
    -   각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당. 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 있는 상태 `안정 상태`
    -   가용 자원이 어떤 기대 자원보다 크지 않으면 할당하지 않음. 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 없는 상태 `불안정 상태`

3. 교착 상태 회피의 문제점

-   `교착 상태 회픠의 원칙`은 교착 상태가 발생하지 않을 수준까지만 자원을 나눠주는 것.
    1.  프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
        -   이는 쉬운 일이 아님. 또한 미리 선언한 자원이 정확하지 않으면 교착 상태 발생 가능.
    2.  시스템의 전체 자원 수가 고정적이어야 한다.
        -   일시적인 고장이나 새로운 자원이 추가되는 일이 빈번하므로 시스템의 자원수는 유동적이다.
    3.  자원이 낭비된다.
        -   모든 불안정 상태가 교착 상태가 되지는 않음. 그럼에도 자원을 할당하지 않는 것은 자원 낭비. 프로세스에 따라 최대 자원을 사용하지 않고도 마치는 프로세스 존재 가능. 교착 상태 회피는 실제로 교착 상태가 발생하지 않는데도 발생할 것이라고 예상함으로써 프로세스에 자원을 할당하는 데 제약을 둔다.

### 3-4. 교착 상태 검출

1. 교착 상태 검출의 개념

-   가장 현실적. 운영체제가 프로세스의 작업을 관찰하면서 교착 상태 발생 여부를 계속 주시하는 방식. 만약 교착 상태가 발견되면 이를 해결하기 위해 교착 상태 회복 단계를 밟음
-   `타임 아웃을 이용하는 방법`, `자원 할당 그래프를 이용하는 방법`이 있다.

2. 타임 아웃을 이용한 교착 상태 검출

-   일정 시간 동안 작업이 진행되지 않은 프로세스를 교착상태가 발생한 것으로 처리. 교착 상태가 자주 발생하지 않을 것이라는 가정하에 사용. 특별한 알고리즘이 없다.
-   문제점
    1.  엉뚱한 프로세스가 강제 종료될 수 있다.
    -   타임아웃 시간 동안 작업이 진행되지 않은 모든 프로세스가 교착 상태 때문에 작업이 이루어지지 않는 것은 아님. 즉 다른 이유로 작업이 진행되지 못하는 프로세스도 강제 종료될 수 있다.
    2.  모든 시스템에 적용할 수 없다.
    -   하나의 운영체제 내에서 동작하는 프로세스들은 상태를 os가 감시하기에 타임아웃 방법을 적용할 수 있다. 그러나 여러 군데에 데이터가 나뉘어 있는 분산 데이터베이스의 경우에는 타임아웃을 이용하는 방법을 적용하기 어렵다.
