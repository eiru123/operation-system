# Chapter.4 스레드와 병행성

* 현대 운영체제는 한 프로세스가 `다중 스레드`를 포함하는 특성을 제공. 다중 CPU를 제공하는 최신 다중 코어 시스템에서 스레드 사용을 통한 병렬 처리의 기회를 식별하는 것이 점차 중요.

## 4.1 개요
* `스레드`: 
  * cpu 이용의 기본 단위. 
  * 스레드 ID, 프로그램 카운터(PC), 레지스터 집합, 스택으로 구성.
  * 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일이나 신호와 같은 운영체제 자원들을 공유.
* 전통적인 프로세스는 하나의 스레드를 가짐. 그러나 다수의 제어 스레드를 가진다면 한 번에 여러 가지 일을 할 수 있다.
### 4.1.1 동기(motivation)
* 현대의 컴퓨터와 모바일 기기에서 작동하는 거의 모든 sw 어플리케이션은 다중 스레드를 이용.
* 하나의 어플리케이션은 여러 개의 실행 흐름을 가진 독립적인 프로세스로 구현됨.
* 다중 스레드 프로그램의 예
  * 이미지 모음에서 사진 축소판을 만드는 프로그램은 별도의 스레드를 사용하여 개별 이미지에서 축소판 생성 가능.
  * 웹 브라우저는 하나의 스레드가 이미지 또는 텍스트를 표시하고 별도의 스레드를 사용하여 개별 이미지에서 축소판 생성 가능.
  * 워드 프로세서에는 그래픽을 표시하는 스레드, 사용자 키 입력에 응답하는 스레드, 백그라운드에서 맞춤법 및 문법 검사를 하는 스레드가 있을 수 있음.
* 웹서버는 여러 클라이언트의 요청을 받는데 단일 스레드 프로세스로 작동한다면 누군가는 응답시간이 엄청 오래 걸릴것이다.
  * 해결책1. 클라이언트마다 프로세스 생성. 멀티 스레드 프로그램 이전의 보편적인 방법. 그러나 프로세스 생성 작업에는 많은 자원이 듦.
  * 해결책2. 할 일이 기존 프로세스가 하는 일과 동일하다면 프로세스 생성의 오버헤드 보다는 스레드를 생성하는 것이 더 효율적이다.
* 대부분의 `운영체제 커널`도 일반적으로 다중 스레드.
* 많은 어플리케이션도 기본 정렬, 트리 및 그래프 알고리즘을 포함하여 다중 스레드를 활용할 수 있다.
* 데이터 마이닝, 그래픽, 인공지능에서 cpu 중심의 최신 문제를 해결해야할 때가 있다. 이 때 병렬로 실행되는 솔루션 설계로 다중 코어 시스템의 성능을 활용할 수 있따.
### 4.1.2 장점
1. 응답성: 대화형 앱을 다중 스레드화 하면 앱의 일부분이 봉쇄되거나 긴 작업을 수행해도 사용자에 대한 응답성을 증가시킬 수 있따.
2. 자원 공유: 스레드는 자신이 속한 프로세스의 자원들과 메모리를 공유한다. 한 앱이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다.
3. 경제성: 프로세스 생성에는 리소스가 많이 필요하다. 스레드는 프로세스의 자원을 공유하기 때문에 context switching시 프로세스에 비해 경제적이다.
4. 규모적응성(scalability): 멀티 스레드는 다중 처리기 구조에 이점이 더 많다. 각각의 스레드가 다른 처리기에서 병렬로 실행될 수 있다.
## 4.2 다중코어 프로그래밍(multicore programming)
* 단일 컴퓨팅 칩에 여러 컴퓨팅 코어를 배치. 이러한 시스템을 multicore 라고 한다. 
* multi thread programming은 이러한 여러 컴퓨팅 코어를 보다 효율적으로 사용하고 병행성을 향상시키는 기법 제공.
* 여러 코어가 있는 시스템에서 각 코어에 별도의 스레드를 할당 할 수 있어 일부 스레드가 병렬로 실행될 수 있다.
* 병행성과 병렬성
  * 병행 시스템: 모든 작업이 진행되게 하여 둘 이상의 작업을 지원
  * 병렬 시스템: 둘 이상의 장업을 `동시`에 수행
  * 병렬성 없이 병행성을 가질 수 있다. cpu 스케쥴러가 프로세스 간에 빠르게 전환해 각 프로세스가 진행되도록 하여 별렬성의 환상을 줌.
#### <암달의 법칙>
* 순차 실행 구성요소와 병렬 실행 구성요소로 이루어진 앱에 추가의 계산 코어를 더했을 때 얻을 수 있는 잠재적인 성능 이득을 나타내는 공식.
* 코어를 아무리 추가해도 최대 2배 이상의 속도 향상은 얻을 수 없다.
### 4.2.1 프로그래밍 도전과제
* os 설계자는 여러 코어를 활용하는 스케쥴링 알고리즘을 개발해야 한다.
* 응용 프로그래머는 기존 프로그램을 다중 스레드를 사용하도록 수정해야 한고 다중 스레드 프로그램을 설계해야 함.
* 다중 코어 시스템을 위해 5개의 극복해야할 과제
  1. 태스크 인식: 앱을 분석하여 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업 필요. 태스크는 `독립적이고` 개별 코어에서 `병렬 실행` 될 수 있어야 함.
  2. 균형: 찾아진 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크를 나눠야 함.
  3. 데이터 분리: 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나누어져야 함.
  4. 데이터 종속성: 테스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다. 종속성이 있는 경우 프로그래머가 태스크의 수행을 잘 `동기화` 해야한다.
  5. 시험 및 디버깅: 병렬로 실행될 때, 다양한 실행 경로가 존재 가능. 이런 프로그램을 시험하고 디버깅하는 것은 단일 스레드 프로그램보다 어렵다.
### 4.2.2 병렬 실행의 유형
* 데이터 병렬과 태스크 병렬
  * 데이터 병렬: 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는 데 초점. 데이터를 나눠서 계산 (1~n/2, n/2~n)
  * 태스크 병렬: 태스크를 다수의 코어에 분배. 각 스레드는 고유의 연산을 실행. 다른 스레드들이 동일한 데이터에 연산을 실행 가능. 또는 다른 데이터에 연산 실행 가능.
* 데이터 병렬 처리에는 여러 코어에 데이트를 분배하는 것이 포함.
* 태스크 병렬 처리에는 여러 코어에 태스크를 분배하는 것이 포함.
* 그러나 둘은 상호 배타적이지 않으며 혼합해서 사용가능.
## 4.3 다중 스레드 모델
* 사용자 스레드와 커널 스레드
  * 사용자 스레드: 사용자 수준에서 제공. 커널 위에서 지원되며 커널의 지원 없이 관리된다.
  * 커널 스레드: 커널 수준에서 제공. 운영체제에 의해 직접 지원되고 관리된다.
  * 사용자 스레드와 커널 스레드는 연관 관계가 존재해야한다.
### 4.3.1 다대일 모델
* 많은 사용자 수준 스레드를 하나의 커널 스레드로 맵핑한다. 
* 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해짐. 효율적이다.
* 한 스레드가 `blocking system call`을 하면 전체 프로세스가 봉쇄된다.
* 한 번에 하나의 스레드만 커널에 접근 가능. 다중 스레드가 다중 코어 시스템에서 병렬 실행될 수 없다.
* 요즘에는 거의 사용 안함.
### 4.3.2 일대일 모델
* 각 사용자 스레드를 각각 하나의 커널스레드로 맵핑.
* 하나의 스레드가 `blocking system call`을 호출하더라도 다른 스레드가 실행될 수 있다. 더 많은 병렬성 제공.
* 다중처리기에서 다중 스레드가 병렬로 수행되는 것을 허용.
* 단점은 사용자 스레드를 만드려면 커널 스레드를 만들어야 한다. 많은 커널 스레드는 시스템 성능에 부담을 줄 수 있다.
* linux는 windows와 함께 일대일 모델 구현
### 4.3.3 다대다 모델
* 여러 개의 사용자 수준 스레드를 그보다 작거나 같은 수의 커널 스레드로 multiflex함.
* 커널 스레드의 수는 프로그램이나 특정 기계에 따라 결정.
* 다대일, 일대일 모델의 단점을 어느정도 해결. 병렬성 제공 및 스레드 생성의 유연성 제공
* 다대다 모델의 변형(two-level model): 많은 사용자 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스 시키지만 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용.
* 실제로는 구현하기 어렵다.
* 처리 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어듬. 
* 대부분의 운영체제는 일대일 모델을 사용.
* 일부 현대 병행 라이브러리는 개발자가 태스크를 식별하면 다대다 모델을 사용하여 스레드에 매핑될 수 있게 한다.
## 스레드 라이브러리
* 프로그래머에게 스레드를 생성하고 관리하기 위한 api를 제공.
* 스레드 라이브러리를 구현하는 방법
  1. 커널의 지원없이 완전히 사용자 공간에서만 라이브러리를 제공. 라이브러리의 모든 코드와 자료구조는 사용자 공간에 존재. 라이브러리 함수를 호출하는 것은 시스템 콜이 아니라 `사용자 공간의 지역함수`
  2. 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현. 라이버러리를 위한 코드와 자료구조는 커널 공간에 존재. 라이브러리 api를 호출하는 것은 커널 시스템 콜을 부르는 결과
* POSIX Pthreads, Windows, java 세 종류의 라이브러리가 주로 사용된다.
  * Pthreads: POSIX 표준안의 스레드 확장판. 사용자 또는 커널 수준 라이브러리로서 제공 된다.
  * windows: window 시스템에서 사용 가능한 커널 수준 라이브러리
  * java: java프로그램에서 직접 스레드 생성과 관리를 가능하게 함. 그러나 대부분의 jvm 구현은 호스트 운영체제에서 실행되기 때문에 java 스레드 api는 통상 호스트 시스템에서 사용 가능한 스레드 라이브러리를 이용하여 구현.
* POSIX, windows의 스레드는 전역 변수로 선언된 데이터는 같은 프로세스에 속한 모든 스레드가 공유한다.
* java는 상응하는 전역 데이터 액세스라는 개념이 없다. 따라서 공유 데이터에 대한 접근이 스레드 사이에 명시적으로 조율되야 함.
* 비동기 스레딩과 동기 스레딩
  * 비동기 스레딩: 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개. 부모와 자식이 서로 독립적으로 병행하게 실행. 스레드가 독립적이기 때문에 스레드 사이의 데이터 공유는 거의 없다. 다중 스레드 서버에서 사용되는 전략. 반응형 사용자 인터페이스 설계에도 흔히 사용.
  * 동기 스레딩: 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 방식. 부모가 생성한 스레드는 병행하게 실행되지만 부모는 자식이 모두 종료된 후 실행된다. 스레드 사이의 상당한 양의 데이터 공유를 수반한다. 예를 들어 부모 스레드는 자식 스레드의 결과를 통합할 수 있다.
### 4.4.1 Pthreads
* POSIX가 스레드 생성과 동기화를 위해 제정한 표준 API. 
* 명세일 뿐 그 자체를 구현한 것은 아님. 명세를 가지고 os 설계자들이 나름대로 구현할 수 있다. linux, macos등이 pthreads 명세를 구현. windows는 pthreads를 지원하지 않더라도 타사가 구현한 버전을 구할 수 있다.
* `runner()`함수에서 스레드의 실행을 시작. 하나의 제어 스레드가 main()함수에서 시작한다. 초기화 후 main()은 runner()함수를 실행을 시작하는 두 번째 스레드를 생성. 두 스레드는 전역 변수를 공유.

## 4.5 암묵적 스레딩 (implicit Threading)
* 